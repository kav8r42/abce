<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    padle lawde
    ye sab kyo 

    ===============LONGEST PALINDROMIC SUBSEQUENCE==================

import java.io.*;
import java.util.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        
        char[] a = s.toCharArray();
        int n = a.length;
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = 1;
            int max = 0;
            for (int j = i - 1; j >= 0; j--) {
                int next = dp[j];
                if (a[i] == a[j])    dp[j] = 2 + max;
                max = Math.max(max, next);
            }
        }
        int max = 0;
        for (int i : dp)    max = Math.max(i, max);
        System.out.println(max);
    }
}

=============================================LONGEST BIOTONIC SUBSEQUENCE===================================

import java.util.*;
import java.lang.*;
import java.io.*;
class Solution
{
    static int lbs( int arr[], int n )
    {
        int i, j;
        /* Allocate memory for LIS[] and initialize LIS values as 1 for
            all indexes */
        int[] lis = new int[n];
        for (i = 0; i < n; i++)
            lis[i] = 1;
        /* Compute LIS values from left to right */
        for (i = 1; i < n; i++)
            for (j = 0; j < i; j++)
                if (arr[i] > arr[j] && lis[i] < lis[j] + 1)
                    lis[i] = lis[j] + 1;
        /* Allocate memory for lds and initialize LDS values for
            all indexes */
        int[] lds = new int [n];
        for (i = 0; i < n; i++)
            lds[i] = 1;
        /* Compute LDS values from right to left */
        for (i = n-2; i >= 0; i--)
            for (j = n-1; j > i; j--)
                if (arr[i] > arr[j] && lds[i] < lds[j] + 1)
                    lds[i] = lds[j] + 1;
        /* Return the maximum value of lis[i] + lds[i] - 1*/
        int max = lis[0] + lds[0] - 1;
        for (i = 1; i < n; i++)
            if (lis[i] + lds[i] - 1 > max)
                max = lis[i] + lds[i] - 1;
        return max;
    }
    public static void main (String[] args)
    {
        Scanner sc=new Scanner(System.in);
        int k=sc.nextInt();
        for(int j=0;j<k;j++)
        {int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        System.out.println(lbs( arr, n ));}
    }
}

=====================================================LONGEST INCREASING SUBSEQUENCE================================

import java.io.*;
import java.util.*;
public class Solution {
    public static int lolis(int[] nums) {
        if (nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxResult = 1;
        for (int i = 1; i < nums.length; i++) {
            int maxVal = 0;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]){
                    maxVal = Math.max(maxVal, dp[j]);
                }
            }
            dp[i] = maxVal + 1;
            maxResult = Math.max(maxResult, dp[i]);
        }
        return maxResult;
    }
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        System.out.println(lolis(arr));
    }
}

============================================LONGEST COMMON SUBSEQUENCE===================================

import java.util.*; 
public class LongestCommonSubsequence { 
int lcs(String X, String Y, int m, int n) 
    { 
        int L[][] = new int[m + 1][n + 1]; 
        for (int i = 0; i <= m; i++) { 
            for (int j = 0; j <= n; j++) { 
                if (i == 0 || j == 0) 
                    L[i][j] = 0; 
                else if (X.charAt(i - 1) == Y.charAt(j - 1)) 
                    L[i][j] = L[i - 1][j - 1] + 1; 
                else
                    L[i][j] = max(L[i - 1][j], L[i][j - 1]); 
            } 
        } 
        return L[m][n]; 
    } 

    // Utility function to get max of 2 integers 
    int max(int a, int b) { return (a > b) ? a : b; } 

    public static void main(String[] args) 
    { 
        LongestCommonSubsequence lcs = new LongestCommonSubsequence(); 
        Scanner sc=new Scanner(System.in);
        String S1 =sc.next() ; 
        String S2 = sc.next(); 
        int m = S1.length(); 
        int n = S2.length(); 
        System.out.println(lcs.lcs(S1, S2, m, n)); 
    } 
} 

====================================================Distributing items when a person cannot take more than two items of same type==========

import java.util.*;

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Read the input as a string
        String inputLine = scanner.nextLine().trim();
        scanner.close();
        
        // Parse the input line
        String[] inputParts = inputLine.split("\\s+");
        List<Integer> sweets = new ArrayList<>();
        for (int i = 0; i < inputParts.length - 1; i++) {
            sweets.add(Integer.parseInt(inputParts[i]));
        }
        
        // Last element of the input is the number of customers k
        int k = Integer.parseInt(inputParts[inputParts.length - 1]);
        
        // Calculate frequency of each type of sweet using a HashMap
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int sweet : sweets) {
            frequencyMap.put(sweet, frequencyMap.getOrDefault(sweet, 0) + 1);
        }
        
        // Calculate how many customers can be satisfied
        int totalSatisfiedCustomers = 0;
        for (int count : frequencyMap.values()) {
            // Each customer can receive up to 2 pieces of each type of sweet
            totalSatisfiedCustomers += count / 2;
        }
        
        // Compare the total satisfied customers with k
        if (totalSatisfiedCustomers >= k) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }
}

==================================HASH MAP TO TREE MAP====================================

import java.io.*;
import java.util.*;

public class Solution {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Read the entire input line from stdin
        String inputLine = scanner.nextLine().trim();
        
        // Close the scanner as it is no longer needed
        scanner.close();
        
        // Remove the surrounding curly braces and spaces from the input line
        inputLine = inputLine.substring(1, inputLine.length() - 1).trim();
        
        // Initialize a HashMap to hold the parsed key-value pairs
        Map<String, Integer> hashMap = new HashMap<>();
        
        // Parse the input line to fill the HashMap
        if (!inputLine.isEmpty()) {
            // Split the input line by commas to separate key-value pairs
            String[] pairs = inputLine.split(",\\s*");
            
            // Iterate over the pairs and parse them
            for (String pair : pairs) {
                // Split the pair into key and value parts using the "->" delimiter
                String[] keyValue = pair.split("->");
                
                // Trim and remove quotes from key
                String key = keyValue[0].trim().replaceAll("\"", "");
                
                // Parse the value as an integer
                int value = Integer.parseInt(keyValue[1].trim());
                
                // Add the key-value pair to the HashMap
                hashMap.put(key, value);
            }
        }
        
        // Convert HashMap to TreeMap to sort the key-value pairs by key
        TreeMap<String, Integer> treeMap = new TreeMap<>(hashMap);
        
        // Build the output string in the required format
        StringBuilder output = new StringBuilder("{ ");
        for (Map.Entry<String, Integer> entry : treeMap.entrySet()) {
            output.append('"').append(entry.getKey()).append('"').append(" -> ").append(entry.getValue()).append(", ");
        }
        
        // Remove the trailing comma and space
        output.setLength(output.length() - 2);
        
        // Close the curly braces
        output.append(" }");
        
        // Print the formatted output
        System.out.println(output.toString());
    }
}

=======================================SUBSET SUM PROBLEM=====================================

import java.util.*;

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Read the first line to get N and M
        int N = scanner.nextInt(); // Number of integers in the set
        int M = scanner.nextInt(); // Target sum
        
        // Read the second line to get the set of integers
        int[] numbers = new int[N];
        for (int i = 0; i < N; i++) {
            numbers[i] = scanner.nextInt();
        }
        
        // Close the scanner
        scanner.close();
        
        // Create a boolean array dp to keep track of possible sums
        boolean[] dp = new boolean[M + 1];
        dp[0] = true; // We can always make a sum of 0 with an empty set
        
        // Process each number in the list
        for (int num : numbers) {
            // Update the dp array from the back to avoid overwriting values we haven't processed yet
            for (int j = M; j >= num; j--) {
                dp[j] = dp[j] || dp[j - num];
            }
        }
        if (dp[M]) {
            System.out.println("yes");
        } else {
            System.out.println("no");
        }
    }
}

==============================================RECOVER THE BST======================================

import java.io.*;
import java.util.*;
class TreeNode
{
    int data;
    TreeNode right;
    TreeNode left;
    TreeNode(int data)
    {
        this.data=data;
        this.left=null;
        this.right=null;
    }
 }
public class Main
{
    static TreeNode build(String st[])
    {
        if(st[0]=="N" || st.length==0)
        return null;
        TreeNode root= new TreeNode(Integer.parseInt(st[0]));
        Queue<TreeNode> Q=new LinkedList<TreeNode>();
        Q.add(root);
        int i=1;
        while(!Q.isEmpty() && i<st.length)
        {
            TreeNode current_element=Q.poll();
            String current_value=st[i];
            if(!current_value.equals("N"))
            {
                int element=Integer.parseInt(current_value);
                current_element.left=new TreeNode(element);
                Q.add(current_element.left);
            }
            i++;
            if(i>=st.length)
              break;
              current_value=st[i];
            if(!current_value.equals("N"))
            {
                int element=Integer.parseInt(current_value);
                current_element.right=new TreeNode(element);
                Q.add(current_element.right);
            }
            i++;  
        }return root;}

     static TreeNode firstNode,secondNode,prevNode;
    public static void recoverTree(TreeNode root) {
        if(root==null)
            return;
        inorderTraversal(root);
        if(firstNode != null && secondNode != null){
            int temp = secondNode.data;
            secondNode.data = firstNode.data;
            firstNode.data = temp;
        }
    }
    private static void inorderTraversal(TreeNode root){
        if(root==null)
            return;
         inorderTraversal(root.left);
        if(prevNode != null && root.data < prevNode.data && firstNode == null) {
               firstNode = prevNode;
        }
        if (prevNode != null && root.data < prevNode.data && firstNode != null) {
               secondNode = root;
        }
        prevNode = root;
        inorderTraversal(root.right);
    }
    public static void inorder(TreeNode temp)
    {
        if(temp==null)
            return;
        System.out.print(temp.data+" ");
        inorder(temp.left);
        inorder(temp.right);
    }
    public static void main(String[] args) throws Exception
    {
       // READING INPUT USING BUFFERED READER
           InputStreamReader r=new InputStreamReader(System.in);    
              BufferedReader br=new BufferedReader(r);      
        String values = br.readLine();
        String st[]=values.split(" ");
        if(st[0].equals("N"))
        {
        System.out.println("0");
        return;
        }
        TreeNode root=build(st);
        recoverTree(root);
            inorder(root);
            br.close();
}
}

==================================================RIGHT VIEW OF BINARY TREE===========================

import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;

    TreeNode(int val) {
        this.val = val;
        left = right = null;
    }
}

public class BinaryTree {
    TreeNode root;

    BinaryTree() {
        root = null;
    }

    void rightView() {
        if (root == null)
            return;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            TreeNode current = null;

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (i == size - 1)
                    current = node;

                if (node.left != null)
                    queue.add(node.left);

                if (node.right != null)
                    queue.add(node.right);
            }
            System.out.print(current.val + " ");
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BinaryTree tree = new BinaryTree();
        String[] nodes = scanner.nextLine().split(" ");
        TreeNode[] nodeArray = new TreeNode[nodes.length];

        for (int i = 0; i < nodes.length; i++) {
            if (!nodes[i].equals("-1"))
                nodeArray[i] = new TreeNode(Integer.parseInt(nodes[i]));
        }

        for (int i = 0; i < nodes.length; i++) {
            if (nodeArray[i] != null) {
                int leftIndex = 2 * i + 1;
                int rightIndex = 2 * i + 2;
                if (leftIndex < nodes.length && nodeArray[leftIndex] != null)
                    nodeArray[i].left = nodeArray[leftIndex];
                if (rightIndex < nodes.length && nodeArray[rightIndex] != null)
                    nodeArray[i].right = nodeArray[rightIndex];
            }
        }

        tree.root = nodeArray[0];
        tree.rightView();
    }
}

================================================LEFT VIEW OF BINARY TREE==========================================

import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;

    TreeNode(int val) {
        this.val = val;
        left = right = null;
    }
}

public class BinaryTree {
    TreeNode root;

    BinaryTree() {
        root = null;
    }

    void leftView() {
        if (root == null)
            return;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            TreeNode current = null;

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (i == 0)
                    current = node;

                if (node.left != null)
                    queue.add(node.left);

                if (node.right != null)
                    queue.add(node.right);
            }
            System.out.print(current.val + " ");
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BinaryTree tree = new BinaryTree();
        String[] nodes = scanner.nextLine().split(" ");
        TreeNode[] nodeArray = new TreeNode[nodes.length];

        for (int i = 0; i < nodes.length; i++) {
            if (!nodes[i].equals("-1"))
                nodeArray[i] = new TreeNode(Integer.parseInt(nodes[i]));
        }

        for (int i = 0; i < nodes.length; i++) {
            if (nodeArray[i] != null) {
                int leftIndex = 2 * i + 1;
                int rightIndex = 2 * i + 2;
                if (leftIndex < nodes.length && nodeArray[leftIndex] != null)
                    nodeArray[i].left = nodeArray[leftIndex];
                if (rightIndex < nodes.length && nodeArray[rightIndex] != null)
                    nodeArray[i].right = nodeArray[rightIndex];
            }
        }

        tree.root = nodeArray[0];
        tree.leftView();
    }
}

===========================================BOTTOM VIEW OF BINARY TREE======================================

//BOTTOM VIEW

import java.util.*;
import java.util.Map.Entry;
class Node {
    int data,hd;
    Node left, right;
    public Node(int data){
        this.data = data;
        left = right = null;
        this.hd = Integer. MAX_VALUE;
    }
}

class Main {
    static Node root;
    private List<Integer> path1 = new ArrayList<>();
    private List<Integer> path2 = new ArrayList<>();
    static Node build(String s[]){
        if(s[0]=="N"||s.length==0)
            return null;
        Node root=new Node(Integer.parseInt(s[0]));
	  Queue<Node> q=new LinkedList<Node>();
        q.add(root);
	     int i=1;
        while(!q.isEmpty() && i<s.length){
            Node curr=q.poll();
            String cval=s[i];
            if(!cval.equals("N")){
                int h=Integer.parseInt(cval);
                curr.left=new Node(h);
                q.add(curr.left);
            }
            i++;
            if(i >= s.length)
                break;
            cval = s[i];
               if(!cval.equals("N")){
                   int h=Integer.parseInt(cval);
                   curr.right=new Node(h);
                   q.add(curr.right);
               }
               i++;
           }
           return root;
	}
 static void bottomview(Node root){
        if (root == null)
            return;
        int hd = 0;
        Map<Integer, Integer> map = new TreeMap<>();
        Queue<Node> queue = new LinkedList<Node>();
        root.hd = hd;
        queue.add(root);
                while (!queue.isEmpty()){
            Node temp = queue.remove();
            hd = temp.hd;
            map.put(hd, temp.data);
            if (temp.left != null){
                temp.left.hd = hd-1;
                queue.add(temp.left);
            }
            if (temp.right != null)
            {
                temp.right.hd = hd+1;
                queue.add(temp.right);
            }
        }
        Set<Entry<Integer, Integer>> set = map.entrySet();
        Iterator<Entry<Integer, Integer>> iterator = set.iterator();
        while (iterator.hasNext()){
            Map.Entry<Integer, Integer> me = iterator.next();
            System.out.print(me.getValue()+" ");
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int i;
        Main ob = new Main();
        String s[]=sc.nextLine().split(" ");
        root = build(s);
        ob.bottomview(root);
 
    }
}

=========================================TOWER OF HANOI=====================================

import java.io.*;
import java.util.*;

public class Solution {
    public static void toh(int n,char from,char to,char aux){
        if(n==0){
            return;
        }
        toh(n-1,from,aux,to);
        System.out.println(from+" "+to);
        toh(n-1,aux,to,from);
    }

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        toh(n,'a','c','b');
    }
}

=========================================WINNER TREE===============================================

import java.util.*;

class Solution{
    public static void main(String arg[]){
        Scanner sc = new Scanner(System.in);
        String[] input = sc.nextLine().split(" "); // Split input string into individual integers
        int[] arr = new int[input.length]; // Initialize an integer array to store the integers
        for (int i = 0; i < input.length; i++) {
            arr[i] = Integer.parseInt(input[i]); // Convert each string to integer and store in array
        }
        Arrays.sort(arr); // Sort the array
        if (arr.length > 1) {
            System.out.println(arr[1]); // Print the second element if array has more than one element
        } else {
            System.out.println("-1"); // Print -1 if array has only one element
        }
    }
}

======================================K-ARRAY HEAP (NOT RUNNING PROPERELY)==========================

import java.util.ArrayList;
import java.util.Scanner;

public class Main {
    private static int n;
    private static ArrayList<Integer> arl = new ArrayList<Integer>();
    
    public static int getMax() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arl.get(0);
    }

    public static boolean isEmpty() {
        return (arl.size() == 0);
    }

    public static void insert(int value) {
        arl.add(value);
        int childrenIndex = arl.size() - 1;
        int parentIndex = (childrenIndex - 1) / n;
        while (parentIndex >= 0 && arl.get(childrenIndex) > arl.get(parentIndex)) {
            int temp = arl.get(childrenIndex);
            arl.set(childrenIndex, arl.get(parentIndex));
            arl.set(parentIndex, temp);

            childrenIndex = parentIndex;
            parentIndex = (childrenIndex - 1) / n;
        }  
    }

    public static void removeMax() {
        arl.set(0, arl.get(arl.size() - 1));
        arl.remove(arl.size() - 1);

        int parentIndex = 0;

        while (true) {
            int largestValueIndex = parentIndex;

            for (int i = n * parentIndex + 1; i <= (n * parentIndex + n) && i < arl.size(); i++) {
                if (arl.get(largestValueIndex) < arl.get(i)) {
                    largestValueIndex = i;
                }
            }

            if (largestValueIndex == parentIndex) {
                break;
            } 
            else {
                int temp = arl.get(parentIndex);
                arl.set(parentIndex, arl.get(largestValueIndex));
                arl.set(largestValueIndex, temp);

                parentIndex = largestValueIndex;
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();

        while (sc.hasNextInt()) {
            int val = sc.nextInt();
            insert(val);
        }

        System.out.println("Built Heap:");
        printHeap();

        System.out.println("Heap after insertion of 3:");
        insert(3);
        printHeap();

        System.out.println("Extracted max is " + getMax());
        removeMax();
        System.out.println("Heap after extract max:");
        printHeap();
    }

    public static void printHeap() {
        for (int i = 0; i < arl.size(); i++) {
            System.out.print(arl.get(i) + " ");
        }
        System.out.println();
    }
}

=================================BINOMIAL HEAP=========================================

import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;

    TreeNode(int val) {
        this.val = val;
        left = right = null;
    }
}

public class BinaryTree {
    TreeNode root;

    BinaryTree() {
        root = null;
    }

    void rightView() {
        if (root == null)
            return;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            TreeNode current = null;

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (i == size - 1)
                    current = node;

                if (node.left != null)
                    queue.add(node.left);

                if (node.right != null)
                    queue.add(node.right);
            }
            System.out.print(current.val + " ");
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BinaryTree tree = new BinaryTree();
        String[] nodes = scanner.nextLine().split(" ");
        TreeNode[] nodeArray = new TreeNode[nodes.length];

        for (int i = 0; i < nodes.length; i++) {
            if (!nodes[i].equals("-1"))
                nodeArray[i] = new TreeNode(Integer.parseInt(nodes[i]));
        }

        for (int i = 0; i < nodes.length; i++) {
            if (nodeArray[i] != null) {
                int leftIndex = 2 * i + 1;
                int rightIndex = 2 * i + 2;
                if (leftIndex < nodes.length && nodeArray[leftIndex] != null)
                    nodeArray[i].left = nodeArray[leftIndex];
                if (rightIndex < nodes.length && nodeArray[rightIndex] != null)
                    nodeArray[i].right = nodeArray[rightIndex];
            }
        }

        tree.root = nodeArray[0];
        tree.rightView();
}
}

====================================TOPOLOGICAL SORT(u need to convert to user input)==============================

//Topological Sort
import java.util.*;

public class TopologicalSort {

    // Function to perform DFS and topological sorting
    static void
    topologicalSortUtil(int v,    List<List<Integer> > adj,
                        boolean[] visited,
                        Stack<Integer> stack)
    {
        // Mark the current node as visited
        visited[v] = true;
      // Recur for all adjacent vertices
        for (int i : adj.get(v)) {
            if (!visited[i])
                topologicalSortUtil(i, adj, visited, stack);7
        }

        // Push current vertex to stack which stores the
        // result
        stack.push(v);
    }

    // Function to perform Topological Sort
    static void topologicalSort(List<List<Integer> > adj,
                                int V)
    {
        // Stack to store the result
        Stack<Integer> stack = new Stack<>();
        boolean[] visited = new boolean[V];

        // Call the recursive helper function to store
        // Topological Sort starting from all vertices one
        // by one
        for (int i = 0; i < V; i++) {
            if (!visited[i])
                topologicalSortUtil(i, adj, visited, stack);
        }

        // Print contents of stack
        System.out.print(
            "Topological sorting of the graph: ");
        while (!stack.isEmpty()) {
            System.out.print(stack.pop() + " ");
        }
    }

    // Driver code
    public static void main(String[] args)
    {
        // Number of nodes
        int V =5;

        // Edges
        List<List<Integer> > edges = new ArrayList<>();
        edges.add(Arrays.asList(0, 1));
        edges.add(Arrays.asList(0, 2));
        edges.add(Arrays.asList(2, 4));
        edges.add(Arrays.asList(4, 1));
        edges.add(Arrays.asList(4, 3));
        edges.add(Arrays.asList(1, 3));
    // Graph represented as an adjacency list
        List<List<Integer> > adj = new ArrayList<>(V);
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }

        for (List<Integer> i : edges) {
            adj.get(i.get(0)).add(i.get(1));
        }
        topologicalSort(adj, V);
    }
 }

===========================================DIALS ALGORITHM=============================

//Dial's Alg
import java.util.*;

public class Graph {
    static final int INF = Integer.MAX_VALUE;
    private int V; // No. of vertices
    // In a weighted graph, we need to store vertex
    // and weight pair for every edge
    private ArrayList<ArrayList<Tuple> > adj;

    public Graph(int v) // Constructor
    {
        this.V = v;
        this.adj = new ArrayList<ArrayList<Tuple> >();
        for (int i = 0; i < v; i++)
            this.adj.add(new ArrayList<Tuple>());
    }

    // function to Add an edge to graph
    // Adds edge between u and v of weight w
    public void AddEdge(int u, int v, int w)
    {
        adj.get(u).add(new Tuple(v, w));
        adj.get(v).add(new Tuple(u, w));
    }

    // Prints shortest paths from src to all other vertices.
    // W is the maximum weight of an edge
    public void shortestPath(int src, int W)
    {
       
        int[] dist = new int[V];
       Arrays.fill(dist, INF);
  ArrayList<Integer>[] B = new ArrayList[W * V + 1];
        for (int i = 0; i < W * V + 1; i++)
            B[i] = new ArrayList<Integer>();

        B[0].add(src);
        dist[src] = 0;

        int idx = 0;
        while (true) {
            // Go sequentially through buckets till one
            // non-empty bucket is found
            while (B[idx].size() == 0 && idx < W * V)
                idx++;

            // If all buckets are empty, we are done.
            if (idx == W * V)
                break;

            // Take top vertex from bucket and pop it
            int u = B[idx].get(0);
            B[idx].remove(0);

            // Process all adjacents of extracted vertex 'u'
            // and update their distances if required.
            for (Tuple i : adj.get(u)) {
                int v = i.v;
                int weight = i.w;

                int du = dist[u];
                int dv = dist[v];

                // If there is shorted path to v through u.
                if (dv > du + weight) {
                    // updating the distance
                    dist[v] = du + weight;
                    dv = dist[v];

                    // pushing vertex v into updated
                    // distance's bucket
                    B[dv].add(0, v);
                }
            }
        }

        // Print shortest distances stored in dist[]
        System.out.println("Vertex Distance from Source");
        for (int i = 0; i < V; ++i)
            System.out.println(i + "\t\t" + dist[i]);
    }

    static class Tuple {
        int v, w;
        Tuple(int v, int w)
        {
            this.v = v;
            this.w = w;
        }
    }
    public static void main(String[] args)
    {
        // create the graph given in above figure
        int V = 6;
        Graph g = new Graph(V);

        // making above shown graph
        g.AddEdge(0, 1, 4);
        g.AddEdge(0, 2, 2);
        g.AddEdge(2, 1, 1);
        g.AddEdge(1, 4, 2);
        g.AddEdge(2, 3, 4);
        g.AddEdge(4, 3, 3);
        g.AddEdge(2, 4, 4);
        g.AddEdge(4, 5, 3);
        g.AddEdge(3, 5, 1);
  

        // maximum weighted edge - 4
        g.shortestPath(0, 4);
    }
}

===============================BELLMAN FORD ALGORITHM============================

import java.util.*;

class Edge {
    int source, destination, weight;

    public Edge(int source, int destination, int weight) {
        this.source = source;
        this.destination = destination;
        this.weight = weight;
    }
}

class BellmanFord {
    int V, E;
    Edge[] edges;

    public BellmanFord(int v, int e) {
        V = v;
        E = e;
        edges = new Edge[E];
    }

    public void bellmanFord(int src) {
        int[] dist = new int[V];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[src] = 0;

        for (int i = 1; i < V; i++) {
            for (int j = 0; j < E; j++) {
                int u = edges[j].source;
                int v = edges[j].destination;
                int weight = edges[j].weight;
                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                }
            }
        }

        for (int j = 0; j < E; j++) {
            int u = edges[j].source;
            int v = edges[j].destination;
            int weight = edges[j].weight;
            if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                System.out.println("-1"); // Graph contains a negative cycle
                return;
            }
        }

        for (int i = 0; i < V; i++) {
            if (dist[i] == Integer.MAX_VALUE) {
                System.out.print("-1 ");
            } else {
                System.out.print(dist[i] + " ");
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt(); // Number of nodes
        int m = scanner.nextInt(); // Number of edges

        BellmanFord bellmanFord = new BellmanFord(n, m);

        for (int i = 0; i < m; i++) {
            int source = scanner.nextInt();
            int destination = scanner.nextInt();
            int weight = scanner.nextInt();
            bellmanFord.edges[i] = new Edge(source, destination, weight);
        }

        bellmanFord.bellmanFord(0);
    }
}

=================================BFS====================================

import java.util.*;
public class BFS {
    int V;
    LinkedList<Integer> adj[];
    BFS(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for(int i=0;i<v;i++)
        {
            adj[i] = new LinkedList();
        }
    }
    void addEdges(int v,int e)
    {
        adj[v].add(e); 
        adj[e].add(v);
    } 
    void bFS(int s)
    {
        boolean visited[] = new boolean[V];
        Queue<Integer> queue = new LinkedList<Integer>();
        visited[s] = true;
        queue.add(s);
         
        while(queue.size()!=0)
        {
            s = queue.poll();
            System.out.print(s + " ");
            
            Iterator<Integer> i = adj[s].listIterator();
            while(i.hasNext())
            {
                int n = i.next();
                if(visited[n] == false)
                {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
      } 
public static void main(String[] args)
{
    Scanner s = new Scanner(System.in);
    int n = s.nextInt();
    if(n==0){
        System.out.println("Graph doesn't exist");
    }else{
        BFS graph = new BFS(n);
    int v,e;
    while(true) {
        v = s.nextInt();
        e = s.nextInt();
        if (v == -1 && e == -1) {
            break; 
        }
        graph.addEdges(v, e);
    }
    //int S = s.nextInt();
    System.out.print("BFS : " );
    graph.bFS(0);
    }
    }
    
}

==========================================DFS===========================================

import java.util.*;

public class DFS {
    int V;
    LinkedList<Integer> adj[];

    DFS(int v) {
        V = v;
        adj = new LinkedList[V];
        for (int i = 0; i < V; i++) {
            adj[i] = new LinkedList();
        }
    }

    void addEdges(int v, int e) {
        if (v >= 0 && v < V && e >= 0 && e < V) {
            adj[v].add(e);
            adj[e].add(v);
        } else {
            System.out.println("Invalid edge: (" + v + ", " + e + ")");
        }
    }

    void dFSrec(int s, boolean[] visited) {
        visited[s] = true;
        System.out.print(s + " ");

        Iterator<Integer> i = adj[s].listIterator();
        while (i.hasNext()) {
            int n = i.next();
            if (!visited[n])
                dFSrec(n, visited);
        }
    }

    void dFS(int s) {
        boolean visited[] = new boolean[V];
        dFSrec(s, visited);
    }

    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt(); // Number of nodes
        int m = scanner.nextInt(); // Number of edges

        DFS g = new DFS(n);

        // Read edges
        for (int i = 0; i < m; i++) {
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            g.addEdges(u, v);
        }

        int source = 0; // Start DFS from node 0
        g.dFS(source);
    }
}

=============================================CELEBRETY PROBLEM===========================

import java.io.*;
import java.util.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        int ans=-1;
        int n=sc.nextInt();
        int arr[][]=new int[n][n];
        for(int i=0;i<n;i++){
            arr[i]=new int[n];
            boolean found=true;
            for(int j=0;j<n;j++){
                arr[i][j]=sc.nextInt();
                if (arr[i][j]==1){
                    found=false;
                }
            }
            if(found){
                ans=i;
            }
        }
        if (ans==-1){
            System.out.print("No Celebrity");
        }
        else{
            for(int i=0;i<ans;i++){
                if(arr[i][ans]!=1){
                    System.out.print("No Celebrity");
                    System.exit(0);
                }
            }
            for(int i=ans+1;i<n;i++){
                if(arr[i][ans]!=1){
                    System.out.print("No Celebrity");
                    System.exit(0);
                }
            }
            System.out.print(ans);
        }    
    }
}

============================================PRIORITY QUEUE==================================

import java.util.*;

public class PriorityQueueLinkedList {
    static class Node {
        int data;
        int priority;
        Node next;

        public Node(int data, int priority) {
            this.data = data;
            this.priority = priority;
            this.next = null;
        }
    }

    private static Node head = null;

    private static void enqueue(int data, int priority) {
        Node newNode = new Node(data, priority);
        if (head == null || priority < head.priority) {
            newNode.next = head;
            head = newNode;
        } else {
            Node temp = head;
            while (temp.next != null && temp.next.priority <= priority) {
                temp = temp.next;
            }
            newNode.next = temp.next;
            temp.next = newNode;
        }
    }

    private static int dequeue() {
        if (head == null) {
            System.out.println("Error List Empty");
            return -1;
        }
        int data = head.data;
        head = head.next;
        return data;
    }

    private static void display() {
        if (head == null) {
            System.out.println("Empty");
            return;
        }
        Node temp = head;
        System.out.print("Queue: ");
        while (temp != null) {
            System.out.print(temp.data + " "+temp.priority+" ");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (true) {
            // System.out.println("1) Insertion\n2) Deletion\n3) Display\n4) Exit");
            int choice = scanner.nextInt();
            switch (choice) {
                case 1:
                    // System.out.println("Enter value and priority:");
                    int value = scanner.nextInt();
                    int priority = scanner.nextInt();
                    enqueue(value, priority);
                    // display();
                    break;
                case 2:
                    int deleted = dequeue();
                    if (deleted != -1) {
                        // System.out.println("Deleted element: " + deleted);
                    }
                    // display();
                    break;
                case 3:
                    display();
                    break;
                case 4:
                    System.exit(0);
                default:
                    System.out.println("Wrong Choice");
            }
        }
    }
}

====================================================MAXIMUM SLIDING WINDOW====================================

import java.util.*;

public class SlidingWindowMaximum {
    public static int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0 || k <= 0) {
            return new int[0];
        }

        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            // Remove indices that are out of the current window
            while (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }

            // Remove indices of elements smaller than the current element from the back
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            deque.offer(i);

            // Add the maximum element in the current window to the result array
            if (i - k + 1 >= 0) {
                result[i - k + 1] = nums[deque.peek()];
            }
        }

        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        int k = scanner.nextInt();

        int[] result = maxSlidingWindow(nums, k);
        for (int num : result) {
            System.out.print(num + " ");
        }
    }
}

========================================STACK PERMUTATION============================================

import java.util.*;

public class StackPermutation {
    public static boolean isStackPermutationPossible(int[] input, int[] output) {
        Stack<Integer> stack = new Stack<>();
        Queue<Integer> inputQueue = new LinkedList<>();
        Queue<Integer> outputQueue = new LinkedList<>();

        // Initialize input queue
        for (int num : input) {
            inputQueue.offer(num);
        }

        // Initialize output queue
        for (int num : output) {
            outputQueue.offer(num);
        }

        // Simulate the stack permutation process
        while (!outputQueue.isEmpty()) {
            int currentOutput = outputQueue.poll();
            if (!stack.isEmpty() && stack.peek() == currentOutput) {
                stack.pop();
            } else {
                while (!inputQueue.isEmpty() && inputQueue.peek() != currentOutput) {
                    stack.push(inputQueue.poll());
                }
                if (inputQueue.isEmpty() || inputQueue.poll() != currentOutput) {
                    return false;
                }
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] inputStr = scanner.nextLine().split(" ");
        String[] outputStr = scanner.nextLine().split(" ");
        int[] input = new int[inputStr.length];
        int[] output = new int[outputStr.length];
        for (int i = 0; i < inputStr.length; i++) {
            input[i] = Integer.parseInt(inputStr[i]);
        }
        for (int i = 0; i < outputStr.length; i++) {
            output[i] = Integer.parseInt(outputStr[i]);
        }

        if (isStackPermutationPossible(input, output)) {
            System.out.println("YES");
        } else {
            System.out.println("Not Possible");
        }
    }
}

=======================================ALL THE BEST===============================================
    
</body>
</html>
